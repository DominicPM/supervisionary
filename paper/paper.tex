\documentclass[a4paper, 10pt]{article}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{microtype}
\usepackage{prooftree}

\usepackage{tgpagella}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}[section]

\newcommand{\deffont}[1]{\ensuremath{\textbf{#1}}}
\newcommand{\fall}[1]{\forall{#1}.\ }
\newcommand{\ite}[3]{\mathtt{if}\ {#1}\ \mathtt{then}\ {#2}\ \mathtt{else}\ {#3}}
\newcommand{\lam}[1]{\lambda{#1}.\ }
\newcommand{\letin}[4]{\mathtt{let}{\;}#1{:}#2{\;}{:=}{\;}#4{\;}\mathtt{in}{\;}#3}
\newcommand{\rulefont}[1]{(\ensuremath{\mathbf{#1}})}
\newcommand{\hthe}[1]{\mathtt{Some}\ {#1}.\ }
\newcommand{\xsts}[1]{\exists{#1}.\ }

\title{All watched over by machines of loving grace}
\author{Dominic P. Mulligan and Nick Spinale}
\date{Systems Research Group, Arm Research, Cambridge}

\begin{document}

\maketitle

\begin{abstract}
To enforce system-wide security policies, many operating systems implement a self-contained \emph{kernel} which serves as the root of all trust within the system.
The kernel is the sole component able to directly interact with hardware, and provides services to executing user-space software, for example the abstraction of a hierarchical filesystem.
User-space code resides outside of the kernel and interacts with it through a defined \emph{ABI}.

To enforce logical soundness, many interactive theorem proving systems implement a self-contained \emph{kernel} which serves as the root of all trust within the system.
The kernel is the sole system component able to authenticate a proof as legitimate.
Untrusted code resides outside of the kernel and interacts with it through a defined \emph{API}.

In this paper, we explore the consequences of structuring proof-checking software as \emph{supervisory software}, adopting system organisation principles typical of operating systems and similar privileged system software.
We develop a proof-checking kernel for Gordon's HOL called \emph{Supervisionary} that is exposed to untrusted code through a defined ABI.
Kernel objects are protected---and important invariants are maintained---through machine-oriented notions of separation, akin to ``privilege rings'' or ``exception levels'' on typical commodity hardware, rather than programming language module boundaries.
We find that this novel structuring has some interesting consequences, which are discussed.
\end{abstract}

\section{Introduction}
\label{sect.introduction}

Interactive theorem proving software typically implements a proof-checking \emph{kernel}.
This kernel is the sole system component that is able to authenticate a purported proof as legitimate, and is typically kept small and self-contained, making it suitable for manual auditing.
By design, the kernel is the only component within the system that need be trusted by a skeptic, as all proofs constructed by the system, no matter how large or complex, are ultimately passed through the kernel for authentication.
This implementation strategy---known as the ``LCF-style'', after Milner's system that first implemented it---is a reliability mechanism, aiming to ensure that any theorem produced by the system is indeed a theorem.
In short, the kernel acts as the \emph{root of all trust} within the system.

Shifting focus, we see an interesting analogy: desktop operating systems---such as Microsoft Windows and desktop Linux distributions---also implement a \emph{kernel}.
This kernel is also the sole system component that has unfettered access to the host machine's hardware\footnote{Barring other privileged systems software, such as the hypervisor, which we consider as another form of operating system}, and will typically provide various abstractions, such as a hierarchically-structured filesystem, sockets, and so on, to untrusted user-space code.
System-wide security policies are enforced by the kernel using a variety of mechanisms, including password-protected user accounts, file and directory permissions, access control lists, firewalls, and runtime-monitoring facilities.
From a security point-of-view, an operating system kernel again acts as the \emph{root of all trust} within the system.

At heart---though intended for very different use-cases---both types of kernel are intended to enforce a series of \emph{kernel invariants} even in the face of unbounded interaction with untrusted code.
However, despite this common cause between the two families of systems, the protection mechanisms used to enforce these invariants tend to be very different.

In particular, an LCF-style kernel is little other than a library implemented in a high-level programming language---typically some variant of ML, such as Standard ML or OCaml.
Invariants are maintained by the kernel judiciously exposing functionality through an API---offering functions to manipulate elements of certain abstract types---and through which untrusted code interacts with the kernel.
Logical soundness is therefore contingent on the type soundness of the implementation meta-language's type-system.

In contrast, desktop operating systems use hardware separation mechanisms to protect various \emph{kernel objects}---that is, book-keeping structures used by the kernel---from unfettered access by untrusted code.
These hardware separation mechanisms include elevated \emph{privilege rings} (or \emph{exception levels})---granting the kernel access to protected hardware resources, such as system registers---and memory protection mechanisms through which the kernel can ``carve out'' a private scratch space to safely stash kernel objects.

\paragraph{Contributions}
We make the following contributions in this paper:

\begin{enumerate}
\item
We design a proof-checking kernel for Gordon's HOL structured around a series of tables of kernel objects indexed by handles.
With this, we introduce \emph{Supervisionary}, a prototype interactive theorem proving system which exposes its kernel as an ABI to WebAssembly programs.
\item
Noting that Supervisionary is little other than an exercise in pointer manipulation, we briefly explore how our ABI can be formally specified, using a variant of Separation Logic.
\item
We exploit Supervisionary's proof checking capabilities to define expressive dynamic security policies for WebAssembly programs.
\end{enumerate}

The remainder of the paper is structured as follows.
In Section~\ref{sect.gordons.hol} we briefly introduce Gordon's HOL.
In Section~\ref{sect.design.supervisionary.kernel} we describe the design of the Supervisionary kernel.
In Section~\ref{sect.supervisionary.system} we describe the Supervisionary system proper, including untrusted support code---the analogue of Unix's \texttt{libc}---that allows WebAssembly programs to interact with the kernel.
In Section~\ref{sect.separation.logic.an.interlude} we briefly explore how Separation Logic can be used to provide a formal description of the action of the Supervisionary ABI.
In Section~\ref{sect.security.policies.for.webassembly} we show how expressive security policies can be captured, and enforced, for arbitrary WebAssembly programs using Supervisionary.
Finally, in Section~\ref{sect.conclusions} we conclude.

\section{Gordon's HOL}
\label{sect.gordons.hol}

Supervisionary implements a version of Gordon's higher-order logic (or HOL, henceforth), a close relative of Church's Simple Theory of Types that extends Church's system with top-level polymorphism.
We describe HOL here, introducing enough material for the reader to understand the remainder of the paper---motivating HOL or describing its expressiveness is outside of the scope of this paper.

We fix a set of \deffont{type-formers}, and use $\mathtt{F}$, $\mathtt{G}$, $\mathtt{H}$, and so on, to range arbitrarily over type-formers.
To each type-former, we associate an \deffont{arity}, and write $arity(\mathtt{F}) = m$ to assert that the arity of type-former $\mathsf{F}$ is $m$.

\begin{definition}
\label{defn.types}
Define \deffont{types} with the following recursive grammar:
\begin{gather*}
\tau, \tau', \tau'' ::= \alpha \mid \mathsf{F}(\tau_1, \ldots, \tau_n)
\end{gather*}
\end{definition}

We work only with \deffont{well-formed types} where each type-former $\mathtt{F}$ is applied to a list of arguments of length $m$ where $arity(\mathtt{F}) = m$.
We fix two \emph{primitive} type-formers that are built-in to the logic: $\mathtt{bool}$ of arity $0$ and $\mathtt{fun}$ of arity $2$.
We write $\mathtt{bool}$ and $\tau \Rightarrow \tau'$ as shorthand for $\mathtt{bool}()$ and $\mathtt{fun}(\tau, \tau')$, the Boolean and function space arrow types, respectively.
Note that the function space arrow associates to the right, and we write $\tau \Rightarrow \tau' \Rightarrow \tau''$ as a more convenient rendering of the type $\tau \Rightarrow (\tau' \Rightarrow \tau'')$.
We write $\tau[\alpha := \tau']$ for the \deffont{substitution action} on types, and write $tv(\tau)$ for the type variables of a type.

To each type $\tau$ we fix a countably infinite set of \deffont{variables}.
We write $x_\tau$, $y_\tau$, $z_\tau$, and so on, to range arbitrarily over variables associated with the type $\tau$.
We adopt the convention that distinctly named variables denote distinct variables, so $x_\tau \neq y_\tau$.
Note that $x_\tau \neq x_{\tau'}$ whenever $\tau \neq \tau'$.

We fix a set of \deffont{constants} and use $\mathtt{C}$, $\mathtt{D}$, $\mathtt{E}$, and so on, to range arbitrarily over constants.
To each constant we associate a type, and write $type(\mathtt{C}) = \tau$ to assert that constant $\mathtt{C}$ was declared with type $\tau$.

\begin{definition}
\label{defn.terms}
Define \deffont{terms} with the following recursive grammar:
\begin{gather*}
r,s,t ::= x_\tau \mid \mathtt{C} \mid rs \mid \lam{x_\tau}r
\end{gather*}
\end{definition}

We write $fv(r)$ for the set of \deffont{free variables} appearing within a term, noting that $x_\tau$ is \emph{bound} in $r$ in the term $\lam{x_\tau}r$, and write $r[x_\tau := t]$ for the usual \deffont{capture-avoiding substitution action} on terms.
We henceforth work with terms quotiented by $\alpha$-equivalence---that is, terms are considered equal up-to a permutative renaming of their bound variables.

We write $tv(r)$ for the set of \deffont{type variables} appearing within a term, and write $r[\alpha := \tau]$ for the extension of the type substitution action on types to terms.
We fix the following \emph{primitive} constants, built into the logic, with declared types:

\begin{displaymath}
\begin{array}{ccc}
\top, \bot & & \mathtt{bool} \\
\neg & & \mathtt{bool} \Rightarrow \mathtt{bool} \\
\vee, \wedge, \longrightarrow, \longleftrightarrow &  & \mathtt{bool} \Rightarrow \mathtt{bool} \Rightarrow \mathtt{bool} \\
= & \quad\text{ with declared type }\quad & \alpha \Rightarrow \alpha \Rightarrow \mathtt{bool} \\
\exists, \forall & & (\alpha \Rightarrow \mathtt{bool}) \Rightarrow \mathtt{bool} \\
\mathtt{Some} & & (\alpha \Rightarrow \mathtt{bool}) \Rightarrow \alpha \\
\end{array}
\end{displaymath}

Note that constants with polymorphic declared types such as $=$ and $\exists$ describe a family of constants related by their type.
We write $=_\tau$ for a specialised form of the primitive equality constant where $type(=_\tau) = \tau \Rightarrow \tau \Rightarrow \mathtt{bool}$---similarly, for constants $\exists_\tau$, $\forall_\tau$, and $\mathtt{Some}_\tau$.
We will, however, often drop the type $\tau$ from the name of constants where no ambiguity arises.

We render $\exists_\tau(\lam{x_\tau}\phi)$ as $\xsts{x_\tau}\phi$, $(\vee \phi)\psi$ as $\phi \vee \psi$, and so on, following standard mathematical practice.
We write $\phi \longleftrightarrow \psi$ as an abbreviation for $\phi =_\mathtt{bool} \psi$.
Note that $\mathtt{Some}$ is our rendering of Hilbert's $\epsilon$-operator, a mechanism for \emph{choosing} elements of a type based on a property.

\begin{figure}[t]
\begin{gather*}
\begin{prooftree}
\phantom{h}
\justifies
x_\tau : \tau
\end{prooftree}
\qquad
\begin{prooftree}
\phantom{h}
\justifies
\mathtt{C}_\tau : \tau
\end{prooftree}
\qquad
\begin{prooftree}
r : \tau \Rightarrow \tau'
\quad
s : \tau
\justifies
rs : \tau'
\end{prooftree}
\qquad
\begin{prooftree}
r : \tau'
\justifies
\lam{x_\tau}r : \tau \Rightarrow \tau'
\end{prooftree}
\end{gather*}
\caption{The typing relation on terms}
\label{fig.typing.relation}
\end{figure}

\begin{definition}
\label{defn.typing.relation}
Define a \deffont{typing relation} on terms by the rules in Figure~\ref{fig.typing.relation}.
We write $r : \tau$ to assert that a derivation tree, rooted at $r : \tau$, and constructed using the rules in Figure~\ref{fig.typing.relation}, exists.
\end{definition}

If $r : \mathtt{bool}$ that we call $r$ a \deffont{formula}.
We will additionally use $\phi$, $\psi$, $\xi$, and so on, to range over formulae.
We call a finite set of terms a \deffont{context}, and use $\Gamma$, $\Gamma'$, $\Gamma''$, and so on, to range over contexts.
We write $\{\}$ for the empty context.

\begin{figure}[t]
\begin{gather*}
\begin{prooftree}
\phantom{h}
\justifies
\{\} \vdash \top
\end{prooftree}
\qquad
\begin{prooftree}
(\phi : \mathtt{bool})
\justifies
\{\phi\} \vdash \phi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \bot
\quad
(\phi : \mathtt{bool})
\justifies
\Gamma \vdash \phi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi
\quad
(\psi : \mathtt{bool})
\justifies
\Gamma \cup \{\psi\} \vdash \phi
\end{prooftree}
\qquad
\begin{prooftree}
(r : \tau)
\justifies
\{\} \vdash r = r
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash r = s
\justifies
\Gamma \vdash s = r
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash r = s
\quad
\Gamma' \vdash s = t
\justifies
\Gamma \cup \Gamma' \vdash r = t
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash r = s
\quad
x_\tau \notin fv(\Gamma)
\justifies
\Gamma \vdash \lam{x_\tau}r = \lam{x_\tau}s
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash f = g
\quad
\Gamma' \vdash r = s
\quad
(f : \tau \Rightarrow \tau', r : \tau)
\justifies
\Gamma \cup \Gamma' \vdash f(r) = g(s)
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi
\quad
\Gamma' \vdash \psi
\justifies
\Gamma \cup \Gamma' \vdash \phi \wedge \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi \wedge \psi
\justifies
\Gamma \vdash \phi
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash \phi \wedge \psi
\justifies
\Gamma \vdash \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \cup \{ \phi \} \vdash \psi
\justifies
\Gamma \vdash \phi \longrightarrow \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi \longrightarrow \psi
\quad
\Gamma' \vdash \phi
\justifies
\Gamma \cup \Gamma' \vdash \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \cup \{ \phi \} \vdash \bot
\justifies
\Gamma \vdash \neg\phi
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash \phi
\quad
\Gamma' \vdash \neg\phi
\justifies
\Gamma \cup \Gamma' \vdash \bot
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi
\justifies
\Gamma \vdash \phi \vee \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \psi
\justifies
\Gamma \vdash \phi \vee \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi \vee \psi
\quad
\Gamma \cup \{ \phi \} \vdash \xi
\quad
\Gamma \cup \{ \psi \} \vdash \xi
\justifies
\Gamma \vdash \xi
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash \phi \longrightarrow \psi
\quad
\Gamma \vdash \psi \longrightarrow \phi
\justifies
\Gamma \vdash \phi \longleftrightarrow \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi \longleftrightarrow \psi
\justifies
\Gamma \vdash \phi \longrightarrow \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi \longleftrightarrow \psi
\justifies
\Gamma \vdash \psi \longrightarrow \phi
\end{prooftree}
\qquad
\begin{prooftree}
(r : \tau \Rightarrow \tau', x_\tau \notin fv(r))
\justifies
\{\} \vdash \lam{x_\tau}r(x_\tau) = r
\end{prooftree}
\\[1ex]
\begin{prooftree}
((\lam{x_\tau}r)t : \tau')
\justifies
\{\} \vdash (\lam{x_\tau}r)t = r[x_\tau := t]
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi
\justifies
\Gamma[\alpha := \tau] \vdash \phi[\alpha := \tau]
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi
\quad
(r : \tau)
\justifies
\Gamma[x_\tau := r] \vdash \phi[x_\tau := r]
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash \phi
\quad
(x_\tau \notin fv(\Gamma))
\justifies
\Gamma \vdash \fall{x_\tau}\phi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \fall{x_\tau}\phi
\quad
(t : \tau)
\justifies
\Gamma \vdash \phi[x_\tau := t]
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \phi[x_\tau := t]
\justifies
\Gamma \vdash \xsts{x_\tau}\phi
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash \xsts{x_\tau}\phi
\quad
\Gamma \cup \{ \phi[x_\tau := y_\tau] \} \vdash \psi
\quad
(y_\tau \notin fv(\Gamma) \cup fv(\psi))
\justifies
\Gamma \vdash \psi
\end{prooftree}
\qquad
\begin{prooftree}
\Gamma \vdash \xsts{x_\alpha}p(x)
\justifies
\Gamma \vdash p(\mathtt{Some}_\alpha\ p)
\end{prooftree}
\end{gather*}
\caption{The Natural Deduction relation}
\label{fig.natural.deduction.relation}
\end{figure}

\begin{definition}
\label{defn.natural.deduction}
Define a \deffont{Natural Deduction relation} between contexts and terms, $\Gamma \vdash r$, using the rules in Figure~\ref{fig.natural.deduction.relation}.
We write $\Gamma \vdash r$ to assert that a derivation tree, rooted at $\Gamma \vdash r$, and constructed using the rules in Figure~\ref{fig.natural.deduction.relation}, exists.
\end{definition}

% Note that the Natural Deduction relation maintains a series of invariants---for example, $\Gamma \vdash r$ implies that $r : \mathtt{bool}$ and also $s : \mathtt{bool}$ for each $s \in \Gamma$.

The set of primitive type-formers and constants defines an implicit \deffont{theory}.
Our version of HOL also includes two \emph{primitive definitional} principles for extending this theory with new defined constants and types, respectively.
Specifically, for a previously-undefined constant $\mathtt{C}$ and a term $r : \tau$ where $fv(r) = \{\}$ the constant $\mathtt{C}$ with declared type $\tau$ is added to the theory, as is an additional axiom $\{\} \vdash \mathtt{C} = r$.
TODO: type-definition

\section{The design of the Supervisionary kernel}
\label{sect.design.supervisionary.kernel}

The Supervisionary kernel maintains a mutable runtime state consisting of a series of mutable \deffont{heaps}.
These heaps are indexed by \deffont{kernel handles}---unsigned integers generated by the kernel---and which can be thought of as pointers to \deffont{kernel objects} in the various heaps.
Importantly, the kernel never exposes kernel objects to untrusted code directly, but performs all manipulations on these objects itself, under instruction by untrusted code.

The Supervisionary kernel uses its heaps as a definitive ``source of truth''.
Whereas an LCF system represents a theorem as an immutable and opaque element of a dedicated theorem \emph{type} within the system's meta-language, Supervisionary represents authenticated theorems as objects within its internal \deffont{heap of theorems}.
Note, for the heap of theorems to be a reliable record of authenticated theorems, any terms, constants, types, and type-formers, mentioned by an entry in the theorem heap (or transitively, thereof) must also be made immutable and put under the control of the kernel---it would be decidedly \emph{inconvenient} if the meaning of a theorem $\{ \} \vdash \phi$ were to change under the nose of the kernel.
As a result, the kernel also maintains separate heaps for registered constants, type-formers, well-formed types, and type-checked terms.

The simplest---and most foundational---of these additional heaps is the \deffont{heap of type-formers}, which records the arities of type-formers registered with the kernel.
When untrusted code requests that a new type-former is registered with the kernel, it calls an ABI function---\texttt{TypeFormer.Handle.Register}---with a supplied arity.
In response, the kernel invents a fresh handle and associates it with the supplied arity, before returning the new handle back to untrusted code to use to refer to the type-former again in future.
Note that we can describe the action of the various ABI functions exposed by the kernel with Hoare triples, using an informal Separation Logic as the assertion language.

Another ABI call, \texttt{TypeFormer.Resolve}, allows one to dereference a handle to obtain the arity of a type-former.
At kernel initialisation, the type-former heap is populated with the arities of the Boolean and function space arrow type-formers, registered at pre-provisioned handles.
These handles are part of the ABI itself, and are required ``common knowledge'' between the kernel and untrusted code, similar to the standard file descriptors \texttt{stdin} and \texttt{stdout} forming part of the Unix ABI.

\begin{figure}[t]
\caption{The internal structure of the kernel's type heap}
\label{fig.type.heap}
\end{figure}

Building on the heap of type-formers is the \deffont{heap of types}.
A key consideration in designing the Supervisionary kernel is handling the recursive structure of definitions like Definitions~\ref{defn.types} and~\ref{defn.terms}.
To this end, cells in the type heap store either a type-variable or a type-former, following the grammar of types.
However, the recursive structure has been captured by replacing all recursive occurrences in the grammar by handles pointing back into the type heap---presented schematically in Figure~\ref{fig.type.heap}---with the reference to a type-former in the grammar of types also replaced by a handle pointing-to a type-former in the relevant heap.

New types are entered into the heap via \texttt{Type.Register.Variable} and \texttt{Type.Register.Combination}, respectively.
The latter of these is the most interesting as the kernel must be careful when entering new type-former entries, owing to its recursive character.
In particular, it must ensure that the heap remains \deffont{inductive} in the sense that no entry in the heap contains ``dangling pointers'', or handles pointing to an unregistered type-former or type.

For types, the Supervisionary kernel enforces \deffont{maximal sharing}, in the sense that trying to register a type with the kernel that has already been registered (up-to syntactic equality) does not make a duplicate copy, but simply returns the handle to the already-registered type.
This allows code inside the kernel to quickly compare types for syntactic equality, by simply comparing handles for equality at the expense of making the registering of types slower.

In addition to commands for registering types, and dereferencing handles, we also provide mechanisms for ``testing'' and ``destructuring'' objects that are pointed-to by handles.
For example \texttt{Type.Split.Combination} takes a handle pointing-to a type-former applied to type arguments as argument and returns a type-former handle and list of type handles as output.

\section{The Supervisionary system}
\label{sect.supervisionary.system}

\section{Separation Logic: an interlude}
\label{sect.separation.logic.an.interlude}

\section{Security policies for WebAssembly}
\label{sect.security.policies.for.webassembly}

\section{Conclusions}
\label{sect.conclusions}

\end{document}












\subsection{Formal specification of the ABI}
\label{subsect.formal.specification.of.the.abi}

\begin{definition}
\label{defn.handle}
Fix a countably infinite set of \deffont{handles}.
We use $h$, $h'$, $h''$, and so on, to range arbitrarily over handles, and write $\vec{h}$ to denote a finite list of handles.
\end{definition}

For a partial function $f : A \rightharpoonup B$ we write $dom(f)$ for the \deffont{domain} of $f$, the set $\{ a \in A \mid f a \text{ is defined} \}$.
If $dom(f)$ is finite then we call $f$ \deffont{finitely supported}.

We write $a \mapsto b$ for the \deffont{singleton function} that maps $a \in A$ to $b \in B$ and is everywhere else undefined, and write $\emptyset$ for the \deffont{empty function} that is everywhere undefined.
Note that $dom(a \mapsto b) = \{a \}$ and $dom(\emptyset) = \{\}$.
For a function $f : A \rightharpoonup B$ we write $f(a \mapsto b)$ where $f(a \mapsto b)(a) = b$ and $f(a \mapsto b)(c) = f(c)$.

We call two functions $f, g : A \rightharpoonup B$ \deffont{disjoint} whenever $dom(f) \cap dom(g) = \{\}$.
For two disjoint functions $f, g : A \rightharpoonup B$ we write $f \uplus g$ for the \deffont{disjoint union} of the two functions, where $(f \uplus g)(a) = f(a)$ if $a \in dom(f)$, $(f \uplus g)(a) = g(a)$ if $a \in dom(g)$, and is otherwise undefined.

\begin{definition}
\label{defn.kernel.objects}
Define \deffont{type}, \deffont{term}, and \deffont{theorem kernel objects} by the following grammars, respectively:
\begin{gather*}
\mathtt{var}(n) \mid \mathtt{comb}(h, \vec{h}) \\
\mathtt{var}(n, h) \mid \mathtt{const}(h, h) \mid \mathtt{app}(h, h) \mid \mathtt{lam}(n, h, h) \\
\mathtt{theorem}(\vec{h}, h)
\end{gather*}
\end{definition}

\begin{definition}
\label{defn.heaps}
Call a finitely supported partial function from handles to natural number arities a \deffont{type-former heap}.
Call a finitely-supported partial function from handles to type kernel objects a \deffont{type heap} (or a \deffont{constant heap}, depending on context).
Call a finitely supported partial function from handles to term kernel objects a \deffont{term heap}.
Call a finitely supported partial function from handles to theorem kernel objects a \deffont{theorem heap}.
\end{definition}

\begin{definition}
\label{defn.runtime.state}
Call a 5-tuple $\langle \frak{F}, \frak{T}, \frak{C}, \frak{R}, \frak{D} \rangle$ a \deffont{runtime state} whenever $\frak{F}$ is a type-former heap, $\frak{T}$ is a type heap, $\frak{C}$ is a constant heap, $\frak{R}$ is a term heap, and $\frak{D}$ is a theorem heap.
We use $\sigma$, $\sigma'$, $\sigma''$, and so on, to range arbitrarily over runtime states.
\end{definition}

\begin{definition}
\label{defn.command.result}
\end{definition}

We have:
\begin{displaymath}
\{ \top \}\quad \mathtt{TypeFormer.Register}(a)\quad \{ \mathtt{result} = \mathtt{Ok}() \otimes \exists h.\ h \mapsto_{tf} a \}
\end{displaymath}
Here, $h \mapsto_{tf} a$ asserts that the handle $h$ points-to a slot in the type-former heap containing the arity, $a$, the precondition $\top$, or truth, indicates that the ABI function may be invoked in any kernel runtime state, $\phi \otimes \psi$ is the \emph{separating conjunction}, and $\mathtt{result} = \mathtt{Ok}()$ indicates that the command terminated successfully.
Commands do not ``fail'' in the typical Hoare-logic sense, but indicate errors by successfully terminating with an error code.

where $\mathtt{result} = \mathtt{Ok}(a)$ asserts the command successfully terminates with $a$:
\begin{displaymath}
\{ h \mapsto_{tf} a \}\quad \mathtt{TypeFormer.Resolve}(h) \quad\{ h \mapsto_{tf} a \otimes \mathtt{result} = \mathtt{Ok}(a) \}
\end{displaymath}

\begin{minipage}[t]{0.5\linewidth}
\begin{gather*}
\{ h \mapsto_{t} \mathtt{Comb}(f, as) \} \\
\mathtt{Type.Register.Combination}(f, as) \\
\{ h \mapsto_{t} \mathtt{Comb}(f, as) \otimes \mathtt{result} = \mathtt{Ok}(h) \}
\end{gather*}
\end{minipage}
\;
\begin{minipage}[t]{0.5\linewidth}
\begin{gather*}
\{ \fall{a\in as}\xsts{t} a \mapsto_t t \otimes f \mapsto_{tf} len(as) \} \\
\mathtt{Type.Register.Combination}(f, as) \\
\{ \xsts{h}\mathtt{result} = \mathtt{Ok}(h) \otimes h \mapsto_t \mathtt{Comb}(f, as)\ \otimes \\ \fall{a\in as}\xsts{t} a \mapsto_t t \otimes f \mapsto_{tf} len(as)\}
\end{gather*}
\end{minipage}

\begin{minipage}[t]{0.5\linewidth}
\begin{gather*}
\{ h \mapsto_t \mathtt{Comb}(f, as) \} \\
\mathtt{Type.Split.Combination}(h) \\
\{ h \mapsto_t \mathtt{Comb}(f, as) \otimes \mathtt{result} = \mathtt{Ok}(f, as) \}
\end{gather*}
\end{minipage}
\begin{minipage}[t]{0.5\linewidth}
\begin{gather*}
\{ h \not\mapsto_t \mathtt{Comb}(f, as) \} \\
\mathtt{Type.Split.Combination}(h) \\
\{ \mathtt{result} = \mathtt{ErrDangle} \}
\end{gather*}
\end{minipage}